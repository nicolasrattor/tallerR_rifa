---
title: "Taller R - Rifa Valentina"
subtitle: "2. Manipulaci√≥n de variables de tiempo"
date: "`26/01/2022`"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: [xaringan-themer.css]
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---


```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
```

```{r xaringan-themer, include=FALSE, warning=FALSE}
library(xaringanthemer)
library(dplyr)
library(guaguas)

dark_yellow <- "#9667db"
light_yellow <- "#F7E9FD"
gray <- "#333333"
blue <- "#4466B0"

style_duo(
  # colors
  primary_color = light_yellow,
  secondary_color = dark_yellow,
  header_color = gray,
  text_color = gray,
  code_inline_color = colorspace::lighten(gray),
  text_bold_color = colorspace::lighten(gray),
  link_color = blue,
  title_slide_text_color = blue,

  # fonts
  header_font_google = google_font("Martel", "300", "400"),
  text_font_google = google_font("Lato"),
  code_font_google = google_font("Fira Mono")
)
```

```{r echo=FALSE,include=FALSE}
#pagedown::chrome_print(input="2.-tiempo.html",output="pdf/2. tiempo.pdf")
```

---

# Contenidos

+ Manipulaci√≥n avanzada de data frames (funciones `pivot` y combinaci√≥n de data frames)

+ **Manipulaci√≥n de fechas: paquete `lubridate`**

+ Visualizaci√≥n de datos con `ggplot2`

+ Estimar desde dise√±os muestrales complejos (paquete `survey` y `srvyr`)

+ Hacer funciones, procesos iterativos e introducci√≥n a paquetes en R


---

class: inverse, center, middle

# 2. Manipulacion de fechas

`Paquete lubridate`

---

background-image: url(https://media2.giphy.com/media/xsF1FSDbjguis/200w.webp?cid=3640f6095c9321d95239485951223fbe)
background-size: cover
class: center, bottom, inverse

# 2. Manipulacion de fechas

---

# Variables de tiempo en R

En este m√≥dulo **solo veremos fechas** üìÜ, pero para horas, minutos y segundos la l√≥gica es la misma.

--

Sin embargo, si bien es posible trabajar variables de tiempo sin herramientas dedicadas, ser√≠a **extremadamente engorroso**, y se requerir√≠an .pur[herramientas medianamente sofisticadas] para transformar estas variables en objetos con los que podamos operar.

--

Para eso `R` ofrece herramientas dedicadas especialmente a solucionarnos la vida. Podr√≠an separarse en 2 tipos:

--

- Herramientas para .pur[organizar fechas en un formato reconocible].

- Herramientas que .pur[traduzcan] estas fechas de formato estandarizado a .medium-par-red[n√∫meros].

---

# Variables de tiempo en R


Y con n√∫meros se pueden hacer muchas cosas: **operaciones matem√°ticas**, **gr√°ficos**, etc. Mientras `R` por detr√°s trabaja con n√∫meros, nosotros seguimos viendo sencillas y amigables fechas üôÉ.

--

```{r}
# Pueden reemplazar esta fecha por sus cumplea√±os
mi_cumple <- ("1993-09-30")
str(mi_cumple)
```

--

```{r}
mi_cumple <- as.Date(mi_cumple)
str(mi_cumple)
```

--

```{r}
as.numeric(mi_cumple)
```

--

La funci√≥n `as.Date()` recibi√≥ una cadena de caracteres y la transform√≥ en un objeto fecha (`date`), y esa fecha aloja un n√∫mero. .medium-par-red[¬øQu√© representa ese n√∫mero?]

---

# Variables de tiempo en R

```{r}
as.numeric(as.Date("1970-01-01"))
```

--

Es la distancia desde un momento **escogido de manera arbitraria**: el .medium-par-red[1 de enero de 1970].

--

`as.Date()` es una funci√≥n sencilla de usar, **pero no es muy robusta para el trabajo con fechas**.

--

```{r}
mi_cumple <- as.Date("30-09-1993"); str(mi_cumple) 
```

--

.pur[No soluciona el problema del ordenamiento]. Requiere asistentes para hacerlo. 


---

# Variables de tiempo en R

--

A√∫n as√≠, **no hay que descartarla**, es muy √∫til cuando el formato es la norma ISO 8661. Esta indica un formato .medium-par-red[YYYY-MM-DD] y una cantidad de d√≠gitos por par√°metro (4-2-2).

--

Dentro del universo de `tidyverse` existe una **librer√≠a especializada para el tratamiento de fechas y horas**.

--

Se llama `lubridate` y su objetivo es hacer m√°s intuitiva la manipulaci√≥n y an√°lisis de este tipo de variables.

--

Veamos algunos operadores b√°sicos muy √∫tiles.

--

`R` base tiene funciones para extraer la fecha y hora en el momento de la consulta.

```{r}
Sys.Date() # La fecha de hoy
Sys.time() # el momento exacto, con fecha, horas, minutos y segundos
```

---

# Manejo de fechas con `lubridate`

--

`lubridate` tiene funciones que hacen lo mismo, pero con un lenguaje m√°s intuitivo.

--

```{r}
library(lubridate) # cargamos lubridate
today() 
now()
```

--

**Hay 2 formas principales para crear una fecha.**

--

- Desde una cadena de caracteres o numeros. 

--

- Desde componentes *date-time* individuales.

---

# Manejo de fechas con `lubridate`

--

.pull-left[

**1. Desde cadenas de caracteres**


- La m√°s habitual es a partir de cadenas de caracteres.

- Existen helpers en `lubridate` que autom√°ticamente ordenan el formato de una variable fecha.

- Solo hay que ordenarlos de acuerdo al input.

- Se aceptan diferentes tipos de separadores.

]

.pull-right[
```{r}
ymd("1993-09-30")
## No asimila bien el mes en espa√±ol
mdy("Sep 30, 1993")
dmy("30/sep/1993")
```

]

---

# Manejo de fechas con `lubridate`

--

Tambi√©n se pueden crear fechas a partir de variables num√©ricas. .medium-par-red[Siempre y cuando respeten el orden y cantidad de d√≠gitos].

--

```{r}
ymd(20190322)
dmy(22032019)
```

--

**2. Creaci√≥n desde componentes *date-time* individuales**

--

A veces las fechas nos llegan en un *data frame* separadas en d√≠a, mes, a√±o.

---

# Manejo de fechas con `lubridate`

--

Debemos unirlas para operarlas como objetos *date*. **Usaremos la base de nacimientos de EEVV 2017**.

--

Para crear un objeto `date` que llamaremos `fecha_nac` usamos la funci√≥n `make_date()` de `lubridate`.


```{r}
# cargamos la base
library(readxl)
library(lubridate)

nac2017 <- read_excel("data/nac_2017.xlsx")

# seleccionamos d√≠a, mes, a√±o de nacimiento y creamos una fecha
nac2017 %>% 
  select(dia_nac, mes_nac, ano_nac) %>% 
  mutate(fecha_nac = make_date(ano_nac, mes_nac, dia_nac)) %>% 
  head(5)
```

---

# Mini-ejercicio 2

--
<br/>
<br/>
Utilizando la base de datos "nac2017" que acabamos de cargar en nuestro entorno de trabajo.

--
<br/>
<br/>
1- Generar dentro de la base de datos (en la misma o un objeto nuevo) una variable llamada "fecha_nac" que contenga en un solo campo la fecha de nacimiento completa de cada nacido.

--
<br/>
<br/>
2- Generar adem√°s una variable llamada "fecha_ins" que contenga en un solo campo la fecha de inscripci√≥n completa de cada nacido.

---

# Mini-ejercicio 2: soluci√≥n

--

Es posible crear ambas variables en un solo paso.


```{r}
nac2017 <- nac2017 %>% 
  mutate(fecha_nac = make_date(ano_nac, mes_nac, dia_nac),
         fecha_ins = make_date(ano_ins, mes_ins, dia_ins)) 
```

```{r}
nac2017 %>% select(ano_nac, mes_nac, dia_nac, ano_ins, mes_ins,
                   dia_ins, fecha_nac, fecha_ins) %>%
  head() 
```



---

# Manejo de fechas con `lubridate`

--

As√≠ como podemos componer una fecha, tambi√©n podemos descomponerla.

--

```{r}
mi_cumple <- dmy("30-09-1993")
year(mi_cumple)
```

--

```{r}
month(mi_cumple, label = T) # con label se pide la etiqueta
```

--

```{r}
mday(mi_cumple)
```

--

```{r}
wday(mi_cumple, label = T) # considera que el d√≠a 1 es el domingo
```

---

# Operaciones aritm√©ticas

--

Por ejemplo, pueden saber .pur[cu√°ntos d√≠as de vida tienen]. 

```{r}
today() - ymd("1993-09-30") 
```

--

Existe un **set de funciones** que sirven para operar sobre periodos de tiempo de una manera .pur[intuitiva y versatil]: se llaman `periods` y algunos da ellos son:

```{r, eval=FALSE}
days(1)
weeks(1)
months(1) # esta funci√≥n es de R base
years(1)
```

--

¬øQu√© podemos hacer con ellos?

```{r}
# ¬øque fecha es en un a√±o y un mes m√°s?
today() + years(1) + months(1)
```

---

# Operaciones aritm√©ticas

--

Podemos, por ejemplo, crear una variable *deadline* que indique cu√°ndo es un mes despu√©s de un punto inicial.

```{r}
inicio <- as.Date("2020-08-30")
inicio + months(1)
```

--

Pero no es una funci√≥n tan robusta. .pur[¬øQu√© pasa con los meses de 31 d√≠as?]

--

```{r}
inicio <- ymd("2020-08-31") # esta otra funci√≥n es parecida a as.Date
inicio + months(1)
```

--

No sabe qu√© hacer y entrega un `NA`. Pero `lubridate()` contiene operadores .pur[robustos] para solucionarlo.

--

```{r}
inicio %m+% months(1)
```


---

# Operaciones aritm√©ticas

--

`%m+%` tambi√©n funciona con a√±os y d√≠as. .medium-par[Tambi√©n existe `%m-%` para restar periodos].

--

```{r}
bisiesto <- ymd("2020-02-29")
bisiesto %m+% years(1)
```

--

```{r}
bisiesto %m+% days(1)
```

--

Adem√°s se pueden generar autom√°ticamente varios periodos. .pur[Esto puede ser muy √∫til para validar datos] üëÄ

```{r}
inicio <- ymd("2020-08-31")
inicio %m+% months(1:6)
```

---


# Operaciones aritm√©ticas

--

Tambien podemos calcular **intervalos de tiempo** entre dos momentos de manera consistente.

--

Para eso utilizamos el operador .medium-par[`%--%`].

--

```{r}
siguiente_a√±o <- today() + years(1)
(today() %--% siguiente_a√±o) / days(1) # diferencia en d√≠as
```

--

Para encontrar cu√°ntos per√≠odos caen dentro de un intervalo, con `%/%` pueden obtener la divisi√≥n entera:

--

```{r}
(today() %--% siguiente_a√±o) / weeks(1)

```

Ahora con `%/%`.

```{r}
(today() %--% siguiente_a√±o) %/% weeks(1)
```


---


# Mini-ejercicio 3

--
<br/>
Vamos a utilizar la base de datos donde creamos "fecha_nac" y "fecha_ins".

--

La variable "fecha_nac" refiere a la .pur[fecha de nacimiento] de un nacido durante el a√±o estad√≠stico 2017 y "fecha_ins" indica la .pur[fecha en que el nacido fue inscrito].

--

1- Genera una variable llamada "dif_days" que indique la **diferencia en d√≠as** entre que los nacidos nacieron y fueron inscritos.

--

2- Genera una variable llamada "dif_weeks" que indique la **diferencia en semanas enteras** (sin decimales) entre que los nacidos nacieron y fueron inscritos.

--

3- Escoje una de las dos variables creadas y **genera una tabla de resumen** que contenga la m√≠nima diferencia, la m√°xima, diferencia media y la mediana.

--

.center[.medium-par[Para resolver el punto 3 usen ` %>% summarise(min(),max(),media(),median())`Ô∏è]]

---


# Mini-ejercicio 3


1- Generar "dif_days".

--

```{r}
nac2017 <- nac2017 %>% 
  mutate(dif_days = (fecha_nac %--% fecha_ins) / days(1))
```

--

2- Generar "dif_weeks".

```{r}
nac2017 <- nac2017 %>% 
  mutate(dif_weeks = (fecha_nac %--% fecha_ins) %/% weeks(1))
```

3- Generaci√≥n tabla de resumen de estad√≠sticos.

```{r}
resumen_dif <- nac2017 %>% summarise(min_dif = min(dif_days),
                                     max_dif = max(dif_days),
                                     media_dif = mean(dif_days),
                                     median_dif = median(dif_days))
```

---

# Manejo de fechas con `lubridate`

--

El uso de `lubridate` puede generar **cierta dificultad** en un principio.

--

Esto debido a la cantidad de operadores nuevos que ofrece (%--%, %m+%, %m-%, etc.).

--

Pero si trabajamos habitualmente con fechas u horas, y son un aspecto importante de nuestro trabajo, vale mucho la pena estudiarlos bien.

--

Pues `lubridate` ofrece herramientas .medium-par-red[precisas] y .medium-par-red[robustas] para el trabajo con datos temporales.

--

.medium-par[Que adem√°s son absolutamente compatibles con las librer√≠as de `tidyverse`].

--

Pueden encontrar much√≠sima m√°s informaci√≥n [aqu√≠](https://lubridate.tidyverse.org/).

---

# Uso pr√°ctico

Para crear series de tiempo

```{r}
# Identificar fecha inicio y fin
inicio <- "2016-11-01"
fin <- "2017-08-01"   

# Contar meses entre medio
meses <- ((ymd(inicio) %--% ymd(fin)) / months(1) )

## Crear serie
ano_mes_dia <- ymd(inicio) %m+% months(0:meses) %>% as.character()
ano_mes_dia

## Si el dia molesta
substr(ano_mes_dia,1,7)
```


---

# Uso pr√°ctico

Recomendaci√≥n: si haces gr√°fico con fechas aprovecha y utiliza lubridate




---

### Recursos utilizados

[Ilustraciones de Allison Horst](https://github.com/allisonhorst/stats-illustrations)

[Tutorial de `lubridate`](https://lubridate.tidyverse.org/)

[Capacitaci√≥n INE variables de tiempo en R](https://capacitacion-r-basico.github.io/sesion_4/#106)


