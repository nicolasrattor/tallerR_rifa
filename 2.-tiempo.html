<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Taller R - Rifa Valentina</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Taller R - Rifa Valentina
## 2. Manipulaci√≥n de variables de tiempo
### <code>19/01/2022</code>

---









---

# Contenidos

+ Manipulaci√≥n avanzada de data frames (funciones `pivot` y combinaci√≥n de data frames)

+ **Manipulaci√≥n de fechas: paquete `lubridate`**

+ Visualizaci√≥n de datos con `ggplot2`

+ Estimar desde dise√±os muestrales complejos (paquete `survey` y `srvyr`)

+ Hacer funciones, procesos iterativos e introducci√≥n a paquetes en R


---

class: inverse, center, middle

# 2. Manipulacion de fechas

`Paquete lubridate`

---

background-image: url(https://media2.giphy.com/media/xsF1FSDbjguis/200w.webp?cid=3640f6095c9321d95239485951223fbe)
background-size: cover
class: center, bottom, inverse

# 2. Manipulacion de fechas

---

# Variables de tiempo en R

En este m√≥dulo **solo veremos fechas** üìÜ, pero para horas, minutos y segundos la l√≥gica es la misma.

--

Sin embargo, si bien es posible trabajar variables de tiempo sin herramientas dedicadas, ser√≠a **extremadamente engorroso**, y se requerir√≠an .pur[herramientas medianamente sofisticadas] para transformar estas variables en objetos con los que podamos operar.

--

Para eso `R` ofrece herramientas dedicadas especialmente a solucionarnos la vida. Podr√≠an separarse en 2 tipos:

--

- Herramientas para .pur[organizar fechas en un formato reconocible].

- Herramientas que .pur[traduzcan] estas fechas de formato estandarizado a .medium-par-red[n√∫meros].

---

# Variables de tiempo en R


Y con n√∫meros se pueden hacer muchas cosas: **operaciones matem√°ticas**, **gr√°ficos**, etc. Mientras `R` por detr√°s trabaja con n√∫meros, nosotros seguimos viendo sencillas y amigables fechas üôÉ.

--


```r
# Pueden reemplazar esta fecha por sus cumplea√±os
mi_cumple &lt;- ("1993-09-30")
str(mi_cumple)
```

```
##  chr "1993-09-30"
```

--


```r
mi_cumple &lt;- as.Date(mi_cumple)
str(mi_cumple)
```

```
##  Date[1:1], format: "1993-09-30"
```

--


```r
as.numeric(mi_cumple)
```

```
## [1] 8673
```

--

La funci√≥n `as.Date()` recibi√≥ una cadena de caracteres y la transform√≥ en un objeto fecha (`date`), y esa fecha aloja un n√∫mero. .medium-par-red[¬øQu√© representa ese n√∫mero?]

---

# Variables de tiempo en R


```r
as.numeric(as.Date("1970-01-01"))
```

```
## [1] 0
```

--

Es la distancia desde un momento **escogido de manera arbitraria**: el .medium-par-red[1 de enero de 1970].

--

`as.Date()` es una funci√≥n sencilla de usar, **pero no es muy robusta para el trabajo con fechas**.

--


```r
mi_cumple &lt;- as.Date("30-09-1993"); str(mi_cumple) 
```

```
##  Date[1:1], format: "0030-09-19"
```

--

.pur[No soluciona el problema del ordenamiento]. Requiere asistentes para hacerlo. 


---

# Variables de tiempo en R

--

A√∫n as√≠, **no hay que descartarla**, es muy √∫til cuando el formato es la norma ISO 8661. Esta indica un formato .medium-par-red[YYYY-MM-DD] y una cantidad de d√≠gitos por par√°metro (4-2-2).

--

Dentro del universo de `tidyverse` existe una **librer√≠a especializada para el tratamiento de fechas y horas**.

--

Se llama `lubridate` y su objetivo es hacer m√°s intuitiva la manipulaci√≥n y an√°lisis de este tipo de variables.

--

Veamos algunos operadores b√°sicos muy √∫tiles.

--

`R` base tiene funciones para extraer la fecha y hora en el momento de la consulta.


```r
Sys.Date() # La fecha de hoy
```

```
## [1] "2022-01-20"
```

```r
Sys.time() # el momento exacto, con fecha, horas, minutos y segundos
```

```
## [1] "2022-01-20 18:32:07 -03"
```

---

# Manejo de fechas con `lubridate`

--

`lubridate` tiene funciones que hacen lo mismo, pero con un lenguaje m√°s intuitivo.

--


```r
library(lubridate) # cargamos lubridate
```

```
## 
## Attaching package: 'lubridate'
```

```
## The following objects are masked from 'package:base':
## 
##     date, intersect, setdiff, union
```

```r
today() 
```

```
## [1] "2022-01-20"
```

```r
now()
```

```
## [1] "2022-01-20 18:32:07 -03"
```

--

**Hay 2 formas principales para crear una fecha.**

--

- Desde una cadena de caracteres o numeros. 

--

- Desde componentes *date-time* individuales.

---

# Manejo de fechas con `lubridate`

--

.pull-left[

**1. Desde cadenas de caracteres**


- La m√°s habitual es a partir de cadenas de caracteres.

- Existen helpers en `lubridate` que autom√°ticamente ordenan el formato de una variable fecha.

- Solo hay que ordenarlos de acuerdo al input.

- Se aceptan diferentes tipos de separadores.

]

.pull-right[

```r
ymd("1993-09-30")
```

```
## [1] "1993-09-30"
```

```r
## No asimila bien el mes en espa√±ol
mdy("Sep 30, 1993")
```

```
## [1] "1993-09-30"
```

```r
dmy("30/sep/1993")
```

```
## [1] "1993-09-30"
```

]

---

# Manejo de fechas con `lubridate`

--

Tambi√©n se pueden crear fechas a partir de variables num√©ricas. .medium-par-red[Siempre y cuando respeten el orden y cantidad de d√≠gitos].

--


```r
ymd(20190322)
```

```
## [1] "2019-03-22"
```

```r
dmy(22032019)
```

```
## [1] "2019-03-22"
```

--

**2. Creaci√≥n desde componentes *date-time* individuales**

--

A veces las fechas nos llegan en un *data frame* separadas en d√≠a, mes, a√±o.

---

# Manejo de fechas con `lubridate`

--

Debemos unirlas para operarlas como objetos *date*. **Usaremos la base de nacimientos de EEVV 2017**.

--

Para crear un objeto `date` que llamaremos `fecha_nac` usamos la funci√≥n `make_date()` de `lubridate`.



```r
# cargamos la base
library(readxl)
library(lubridate)

nac2017 &lt;- read_excel("data/nac_2017.xlsx")

# seleccionamos d√≠a, mes, a√±o de nacimiento y creamos una fecha
nac2017 %&gt;% 
  select(dia_nac, mes_nac, ano_nac) %&gt;% 
  mutate(fecha_nac = make_date(ano_nac, mes_nac, dia_nac)) %&gt;% 
  head(5)
```

```
## # A tibble: 5 x 4
##   dia_nac mes_nac ano_nac fecha_nac 
##     &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;date&gt;    
## 1      27      11    2017 2017-11-27
## 2      27       1    2017 2017-01-27
## 3      21       3    2017 2017-03-21
## 4      28       6    2017 2017-06-28
## 5      10       4    2017 2017-04-10
```

---

# Mini-ejercicio 2

--
&lt;br/&gt;
&lt;br/&gt;
Utilizando la base de datos "nac2017" que acabamos de cargar en nuestro entorno de trabajo.

--
&lt;br/&gt;
&lt;br/&gt;
1- Generar dentro de la base de datos (en la misma o un objeto nuevo) una variable llamada "fecha_nac" que contenga en un solo campo la fecha de nacimiento completa de cada nacido.

--
&lt;br/&gt;
&lt;br/&gt;
2- Generar adem√°s una variable llamada "fecha_ins" que contenga en un solo campo la fecha de inscripci√≥n completa de cada nacido.

---

# Mini-ejercicio 2: soluci√≥n

--

Es posible crear ambas variables en un solo paso.



```r
nac2017 &lt;- nac2017 %&gt;% 
  mutate(fecha_nac = make_date(ano_nac, mes_nac, dia_nac),
         fecha_ins = make_date(ano_ins, mes_ins, dia_ins)) 
```


```r
nac2017 %&gt;% select(ano_nac, mes_nac, dia_nac, ano_ins, mes_ins,
                   dia_ins, fecha_nac, fecha_ins) %&gt;%
  head() 
```

```
## # A tibble: 6 x 8
##   ano_nac mes_nac dia_nac ano_ins mes_ins dia_ins fecha_nac  fecha_ins 
##     &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;date&gt;     &lt;date&gt;    
## 1    2017      11      27    2017      11      30 2017-11-27 2017-11-30
## 2    2017       1      27    2017       2       2 2017-01-27 2017-02-02
## 3    2017       3      21    2017       3      23 2017-03-21 2017-03-23
## 4    2017       6      28    2017       7       3 2017-06-28 2017-07-03
## 5    2017       4      10    2017       4      13 2017-04-10 2017-04-13
## 6    2017      10      14    2017      10      16 2017-10-14 2017-10-16
```



---

# Manejo de fechas con `lubridate`

--

As√≠ como podemos componer una fecha, tambi√©n podemos descomponerla.

--


```r
mi_cumple &lt;- dmy("30-09-1993")
year(mi_cumple)
```

```
## [1] 1993
```

--


```r
month(mi_cumple, label = T) # con label se pide la etiqueta
```

```
## [1] sept
## 12 Levels: ene &lt; feb &lt; mar &lt; abr &lt; may &lt; jun &lt; jul &lt; ago &lt; sept &lt; ... &lt; dic
```

--


```r
mday(mi_cumple)
```

```
## [1] 30
```

--


```r
wday(mi_cumple, label = T) # considera que el d√≠a 1 es el domingo
```

```
## [1] jue\\.
## Levels: dom\\. &lt; lun\\. &lt; mar\\. &lt; mi√©\\. &lt; jue\\. &lt; vie\\. &lt; s√°b\\.
```

---

# Operaciones aritm√©ticas

--

Por ejemplo, pueden saber .pur[cu√°ntos d√≠as de vida tienen]. 


```r
today() - ymd("1993-09-30") 
```

```
## Time difference of 10339 days
```

--

Existe un **set de funciones** que sirven para operar sobre periodos de tiempo de una manera .pur[intuitiva y versatil]: se llaman `periods` y algunos da ellos son:


```r
days(1)
weeks(1)
months(1) # esta funci√≥n es de R base
years(1)
```

--

¬øQu√© podemos hacer con ellos?


```r
# ¬øque fecha es en un a√±o y un mes m√°s?
today() + years(1) + months(1)
```

```
## [1] "2023-02-20"
```

---

# Operaciones aritm√©ticas

--

Podemos, por ejemplo, crear una variable *deadline* que indique cu√°ndo es un mes despu√©s de un punto inicial.


```r
inicio &lt;- as.Date("2020-08-30")
inicio + months(1)
```

```
## [1] "2020-09-30"
```

--

Pero no es una funci√≥n tan robusta. .pur[¬øQu√© pasa con los meses de 31 d√≠as?]

--


```r
inicio &lt;- ymd("2020-08-31") # esta otra funci√≥n es parecida a as.Date
inicio + months(1)
```

```
## [1] NA
```

--

No sabe qu√© hacer y entrega un `NA`. Pero `lubridate()` contiene operadores .pur[robustos] para solucionarlo.

--


```r
inicio %m+% months(1)
```

```
## [1] "2020-09-30"
```


---

# Operaciones aritm√©ticas

--

`%m+%` tambi√©n funciona con a√±os y d√≠as. .medium-par[Tambi√©n existe `%m-%` para restar periodos].

--


```r
bisiesto &lt;- ymd("2020-02-29")
bisiesto %m+% years(1)
```

```
## [1] "2021-02-28"
```

--


```r
bisiesto %m+% days(1)
```

```
## [1] "2020-03-01"
```

--

Adem√°s se pueden generar autom√°ticamente varios periodos. .pur[Esto puede ser muy √∫til para validar datos] üëÄ


```r
inicio &lt;- ymd("2020-08-31")
inicio %m+% months(1:6)
```

```
## [1] "2020-09-30" "2020-10-31" "2020-11-30" "2020-12-31" "2021-01-31"
## [6] "2021-02-28"
```

---


# Operaciones aritm√©ticas

--

Tambien podemos calcular **intervalos de tiempo** entre dos momentos de manera consistente.

--

Para eso utilizamos el operador .medium-par[`%--%`].

--


```r
siguiente_a√±o &lt;- today() + years(1)
(today() %--% siguiente_a√±o) / days(1) # diferencia en d√≠as
```

```
## [1] 365
```

--

Para encontrar cu√°ntos per√≠odos caen dentro de un intervalo, con `%/%` pueden obtener la divisi√≥n entera:

--


```r
(today() %--% siguiente_a√±o) / weeks(1)
```

```
## [1] 52.14286
```

Ahora con `%/%`.


```r
(today() %--% siguiente_a√±o) %/% weeks(1)
```

```
## [1] 52
```


---


# Mini-ejercicio 3

--
&lt;br/&gt;
Vamos a utilizar la base de datos donde creamos "fecha_nac" y "fecha_ins".

--

La variable "fecha_nac" refiere a la .pur[fecha de nacimiento] de un nacido durante el a√±o estad√≠stico 2017 y "fecha_ins" indica la .pur[fecha en que el nacido fue inscrito].

--

1- Genera una variable llamada "dif_days" que indique la **diferencia en d√≠as** entre que los nacidos nacieron y fueron inscritos.

--

2- Genera una variable llamada "dif_weeks" que indique la **diferencia en semanas enteras** (sin decimales) entre que los nacidos nacieron y fueron inscritos.

--

3- Escoje una de las dos variables creadas y **genera una tabla de resumen** que contenga la m√≠nima diferencia, la m√°xima, diferencia media y la mediana.

--

.center[.medium-par[Para resolver el punto 3 usen ` %&gt;% summarise(min(),max(),media(),median())`Ô∏è]]

---


# Mini-ejercicio 3


1- Generar "dif_days".

--


```r
nac2017 &lt;- nac2017 %&gt;% 
  mutate(dif_days = (fecha_nac %--% fecha_ins) / days(1))
```

--

2- Generar "dif_weeks".


```r
nac2017 &lt;- nac2017 %&gt;% 
  mutate(dif_weeks = (fecha_nac %--% fecha_ins) %/% weeks(1))
```

3- Generaci√≥n tabla de resumen de estad√≠sticos.


```r
resumen_dif &lt;- nac2017 %&gt;% summarise(min_dif = min(dif_days),
                                     max_dif = max(dif_days),
                                     media_dif = mean(dif_days),
                                     median_dif = median(dif_days))
```

---

# Manejo de fechas con `lubridate`

--

El uso de `lubridate` puede generar **cierta dificultad** en un principio.

--

Esto debido a la cantidad de operadores nuevos que ofrece (%--%, %m+%, %m-%, etc.).

--

Pero si trabajamos habitualmente con fechas u horas, y son un aspecto importante de nuestro trabajo, vale mucho la pena estudiarlos bien.

--

Pues `lubridate` ofrece herramientas .medium-par-red[precisas] y .medium-par-red[robustas] para el trabajo con datos temporales.

--

.medium-par[Que adem√°s son absolutamente compatibles con las librer√≠as de `tidyverse`].

--

Pueden encontrar much√≠sima m√°s informaci√≥n [aqu√≠](https://lubridate.tidyverse.org/).

---

# Uso pr√°ctico

Para crear series de tiempo


```r
# Identificar fecha inicio y fin
inicio &lt;- "2016-11-01"
fin &lt;- "2017-08-01"   

# Contar meses entre medio
meses &lt;- ((ymd(inicio) %--% ymd(fin)) / months(1) )

## Crear serie
ano_mes_dia &lt;- ymd(inicio) %m+% months(0:meses) %&gt;% as.character()
ano_mes_dia
```

```
##  [1] "2016-11-01" "2016-12-01" "2017-01-01" "2017-02-01" "2017-03-01"
##  [6] "2017-04-01" "2017-05-01" "2017-06-01" "2017-07-01" "2017-08-01"
```

```r
## Si el dia molesta
substr(ano_mes_dia,1,7)
```

```
##  [1] "2016-11" "2016-12" "2017-01" "2017-02" "2017-03" "2017-04" "2017-05"
##  [8] "2017-06" "2017-07" "2017-08"
```


---

# Uso pr√°ctico

Recomendaci√≥n: si haces gr√°fico con fechas aprovecha y utiliza lubridate




---

### Recursos utilizados

[Ilustraciones de Allison Horst](https://github.com/allisonhorst/stats-illustrations)

[Tutorial de `lubridate`](https://lubridate.tidyverse.org/)

[Capacitaci√≥n INE variables de tiempo en R](https://capacitacion-r-basico.github.io/sesion_4/#106)


    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
