<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Taller R - Rifa Valentina</title>
    <meta charset="utf-8" />
    <meta name="author" content="Nicol√°s Ratto" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Taller R - Rifa Valentina
## Manipulaci√≥n del tiempo
### Nicol√°s Ratto
### <code>26/01/2022</code>

---










# Contenidos

+ Manipulaci√≥n avanzada de data frames (funciones `pivot` y combinaci√≥n de data frames)

+ **Manipulaci√≥n de fechas: paquete `lubridate`**

+ Visualizaci√≥n de datos con `ggplot2`

+ Estimar desde dise√±os muestrales complejos (paquete `survey` y `srvyr`)

+ Hacer funciones, procesos iterativos e introducci√≥n a paquetes en R


---

background-image: url(https://media2.giphy.com/media/xsF1FSDbjguis/200w.webp?cid=3640f6095c9321d95239485951223fbe)
background-size: cover
class: center, bottom, inverse

# Manipulacion de fechas

---

# Variables de tiempo en R

En este m√≥dulo **solo veremos fechas** üìÜ, pero para horas, minutos y segundos la l√≥gica es la misma.

--

Sin embargo, si bien es posible trabajar variables de tiempo sin herramientas dedicadas, ser√≠a **extremadamente engorroso**, y se requerir√≠an .pur[herramientas medianamente sofisticadas] para transformar estas variables en objetos con los que podamos operar.

--

Para eso `R` ofrece herramientas dedicadas especialmente a solucionarnos la vida. Podr√≠an separarse en 2 tipos:

--

- Herramientas para .pur[organizar fechas en un formato reconocible].

- Herramientas que .pur[traduzcan] estas fechas de formato estandarizado a .medium-par-red[n√∫meros].

---

# Variables de tiempo en R


Y con n√∫meros se pueden hacer muchas cosas: **operaciones matem√°ticas**, **gr√°ficos**, etc. Mientras `R` por detr√°s trabaja con n√∫meros, nosotros seguimos viendo sencillas y amigables fechas üôÉ.

--


```r
# Pueden reemplazar esta fecha por sus cumplea√±os
mi_cumple &lt;- ("1993-09-30")
str(mi_cumple)
```

```
##  chr "1993-09-30"
```

--


```r
mi_cumple &lt;- as.Date(mi_cumple)
str(mi_cumple)
```

```
##  Date[1:1], format: "1993-09-30"
```

--


```r
as.numeric(mi_cumple)
```

```
## [1] 8673
```

--

La funci√≥n `as.Date()` nos dio un n√∫mero. .medium-par-red[¬øQu√© representa ese n√∫mero?]

---

# Variables de tiempo en R


```r
as.numeric(as.Date("1970-01-01"))
```

```
## [1] 0
```

--

Es la distancia desde un momento **escogido de manera arbitraria**: el .medium-par-red[1 de enero de 1970].

--

`as.Date()` es una funci√≥n sencilla de usar, **pero no es muy robusta para el trabajo con fechas**.

--


```r
mi_cumple &lt;- as.Date("30-09-1993"); str(mi_cumple) 
```

```
##  Date[1:1], format: "0030-09-19"
```

--

.pur[No soluciona el problema del ordenamiento]. Requiere asistentes para hacerlo. 


---

# Variables de tiempo en R

--

A√∫n as√≠, **no hay que descartarla**, es muy √∫til cuando el formato es la norma ISO 8661. Esta indica un formato .medium-par-red[YYYY-MM-DD] y una cantidad de d√≠gitos por par√°metro (4-2-2).

--

Dentro del universo de `tidyverse` existe una **librer√≠a especializada para el tratamiento de fechas y horas**.

--

Se llama `lubridate` y su objetivo es hacer m√°s intuitiva la manipulaci√≥n y an√°lisis de este tipo de variables.

--

&lt;a href="https://lubridate.tidyverse.org/index.html" target="_blank"&gt;&lt;img src="https://raw.githubusercontent.com/tidyverse/lubridate/main/man/figures/logo.png" width="20%" style="display: block; margin: auto;" /&gt;&lt;/a&gt;



---

# Variables de tiempo en R

Veamos algunos operadores b√°sicos muy √∫tiles.

--

`R` base tiene funciones para extraer la fecha y hora en el momento de la consulta.


```r
Sys.Date() # La fecha de hoy
```

```
## [1] "2022-01-24"
```

```r
Sys.time() # el momento exacto, con fecha, horas, minutos y segundos
```

```
## [1] "2022-01-24 18:15:40 -03"
```

---

# Usando `lubridate`

--

`lubridate` tiene funciones que hacen lo mismo, pero con un lenguaje m√°s intuitivo.

--


```r
library(lubridate) # cargamos lubridate
today() 
```

```
## [1] "2022-01-24"
```

```r
now()
```

```
## [1] "2022-01-24 18:15:40 -03"
```

--

**Hay 2 formas principales para crear una fecha.**

--

- Desde una cadena de caracteres o n√∫meros. 

--

- Desde componentes *date-time* individuales.

---

# Usando `lubridate`

--

.pull-left[

**1. Desde cadenas de caracteres**


- La m√°s habitual es a partir de cadenas de caracteres.

- Existen helpers en `lubridate` que autom√°ticamente ordenan el formato de una variable fecha.

- Solo hay que ordenarlos de acuerdo al input.

- Se aceptan diferentes tipos de separadores.

]

.pull-right[

```r
ymd("1993-09-30")
```

```
## [1] "1993-09-30"
```

```r
## No asimila bien el mes en espa√±ol
mdy("Sep 30, 1993")
```

```
## [1] "1993-09-30"
```

```r
dmy("30/sep/1993")
```

```
## [1] "1993-09-30"
```

]

---

# Usando `lubridate`

--

Tambi√©n se pueden crear fechas a partir de variables num√©ricas. .medium-par-red[Siempre y cuando respeten el orden y cantidad de d√≠gitos].

--


```r
ymd(20190322)
```

```
## [1] "2019-03-22"
```

```r
dmy(22032019)
```

```
## [1] "2019-03-22"
```


---

# Usando `lubridate`

**2. Creaci√≥n desde componentes *date-time* individuales**

--

A veces las fechas nos llegan en un *data frame* separadas en d√≠a, mes, a√±o.

--

Debemos unirlas para operarlas como objetos *date*. 

--

**Usaremos la base de nacimientos de EEVV 2017**.

--

Usamos la funci√≥n `make_date()` de `lubridate`.



```r
# cargamos la base
library(readxl)
library(lubridate)

nac2017 &lt;- read_excel("data/nac_2017.xlsx")
```

--


```r
# seleccionamos d√≠a, mes, a√±o de nacimiento y creamos una fecha
nac2017 %&gt;% 
  mutate(fecha_nac = make_date(year=ano_nac, 
                               month=mes_nac, 
                               day=dia_nac)) 
```

---

# Usando `lubridate`


```
## # A tibble: 5 x 4
##   dia_nac mes_nac ano_nac fecha_nac 
##     &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;date&gt;    
## 1      27      11    2017 2017-11-27
## 2      27       1    2017 2017-01-27
## 3      21       3    2017 2017-03-21
## 4      28       6    2017 2017-06-28
## 5      10       4    2017 2017-04-10
```

--

Si no hay variable d√≠a, utilizar car√°cter "01"

--


```r
nac2017 %&gt;% 
  mutate(fecha_nac = make_date(year=ano_nac, 
                               month=mes_nac, 
                               day="01")) 
```


---

# Mini ejercicio 

Crear variable fecha de nacimiento y fecha de inscripci√≥n.


```r
nac2017 &lt;- nac2017 %&gt;% 
  mutate(fecha_nac = make_date(ano_nac, mes_nac, dia_nac),
         fecha_ins = make_date(ano_ins, mes_ins, dia_ins)) 
```


```r
nac2017 %&gt;% select(ano_nac, mes_nac, dia_nac, ano_ins, mes_ins,
                   dia_ins, fecha_nac, fecha_ins) %&gt;%
  head() 
```

```
## # A tibble: 6 x 8
##   ano_nac mes_nac dia_nac ano_ins mes_ins dia_ins fecha_nac  fecha_ins 
##     &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;date&gt;     &lt;date&gt;    
## 1    2017      11      27    2017      11      30 2017-11-27 2017-11-30
## 2    2017       1      27    2017       2       2 2017-01-27 2017-02-02
## 3    2017       3      21    2017       3      23 2017-03-21 2017-03-23
## 4    2017       6      28    2017       7       3 2017-06-28 2017-07-03
## 5    2017       4      10    2017       4      13 2017-04-10 2017-04-13
## 6    2017      10      14    2017      10      16 2017-10-14 2017-10-16
```



---

# Usando `lubridate`

--

As√≠ como podemos componer una fecha, tambi√©n podemos descomponerla.

--


```r
mi_cumple &lt;- dmy("30-09-1993")
year(mi_cumple)
```

```
## [1] 1993
```

--


```r
month(mi_cumple, label = T) # con label se pide la etiqueta
```

```
## [1] sept
## 12 Levels: ene &lt; feb &lt; mar &lt; abr &lt; may &lt; jun &lt; jul &lt; ago &lt; sept &lt; ... &lt; dic
```

--


```r
mday(mi_cumple)
```

```
## [1] 30
```

--


```r
wday(mi_cumple, label = T) # considera que el d√≠a 1 es el domingo
```

```
## [1] jue\\.
## Levels: dom\\. &lt; lun\\. &lt; mar\\. &lt; mi√©\\. &lt; jue\\. &lt; vie\\. &lt; s√°b\\.
```

---

# Operaciones aritm√©ticas

--

Por ejemplo, pueden saber .pur[cu√°ntos d√≠as de vida tienen]. 


```r
today() - ymd("1993-09-30") 
```

```
## Time difference of 10343 days
```

--

Existe un **set de funciones** que sirven para operar sobre periodos de tiempo de una manera .pur[intuitiva y versatil]: se llaman `periods` y algunos da ellos son:


```r
days(1)
weeks(1)
months(1) # esta funci√≥n es de R base
years(1)
```

--

¬øQu√© podemos hacer con ellos?


```r
# ¬øque fecha es en un a√±o y un mes m√°s?
today() + years(1) + months(1)
```

```
## [1] "2023-02-24"
```

---

# Operaciones aritm√©ticas

--

Podemos, por ejemplo, crear una variable *deadline* que indique cu√°ndo es un mes despu√©s de un punto inicial.


```r
inicio &lt;- as.Date("2020-08-30")
inicio + months(1)
```

```
## [1] "2020-09-30"
```

--

Pero no es una funci√≥n tan robusta. .pur[¬øQu√© pasa con los meses de 31 d√≠as?]

--


```r
inicio &lt;- ymd("2020-08-31") # esta otra funci√≥n es parecida a as.Date
inicio + months(1)
```

```
## [1] NA
```

--

No sabe qu√© hacer y entrega un `NA`. Pero `lubridate()` contiene operadores .pur[robustos] para solucionarlo.

--


```r
inicio %m+% months(1)
```

```
## [1] "2020-09-30"
```


---

# Operaciones aritm√©ticas

--

`%m+%` tambi√©n funciona con a√±os y d√≠as. .medium-par[Tambi√©n existe `%m-%` para restar periodos].

--


```r
bisiesto &lt;- ymd("2020-02-29")
bisiesto %m+% years(1)
```

```
## [1] "2021-02-28"
```

--


```r
bisiesto %m+% days(1)
```

```
## [1] "2020-03-01"
```

--

Adem√°s se pueden generar autom√°ticamente varios periodos.


```r
inicio &lt;- ymd("2020-08-31")
inicio %m+% months(1:6)
```

```
## [1] "2020-09-30" "2020-10-31" "2020-11-30" "2020-12-31" "2021-01-31"
## [6] "2021-02-28"
```

---


# Operaciones aritm√©ticas

--

Tambien podemos calcular **intervalos de tiempo** entre dos momentos de manera consistente.

--

Para eso utilizamos el operador .medium-par[`%--%`].

--


```r
siguiente_a√±o &lt;- today() + years(1)
(today() %--% siguiente_a√±o) / days(1) # diferencia en d√≠as
```

```
## [1] 365
```

--

Para encontrar cu√°ntos per√≠odos caen dentro de un intervalo, con `%/%` pueden obtener la divisi√≥n entera:

--


```r
(today() %--% siguiente_a√±o) / weeks(1)
```

```
## [1] 52.14286
```

Ahora con `%/%`.


```r
(today() %--% siguiente_a√±o) %/% weeks(1)
```

```
## [1] 52
```


---


# Mini-ejercicio

1- Generar "dif_days" entre fecha nacimiento e inscripci√≥n

--


```r
nac2017 &lt;- nac2017 %&gt;% 
  mutate(dif_days = (fecha_nac %--% fecha_ins) / days(1))
```

--

2- Generar "dif_weeks".


```r
nac2017 &lt;- nac2017 %&gt;% 
  mutate(dif_weeks = (fecha_nac %--% fecha_ins) %/% weeks(1))
```

3- Generaci√≥n tabla de resumen de estad√≠sticos.


```r
nac2017 %&gt;% summarise(min_dif = min(dif_days),
                                     max_dif = max(dif_days),
                                     media_dif = mean(dif_days),
                                     median_dif = median(dif_days))
```

```
## # A tibble: 1 x 4
##   min_dif max_dif media_dif median_dif
##     &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1       0     397      3.89          3
```

---

# Usando `lubridate`

--

El uso de `lubridate` puede generar **cierta dificultad** en un principio.

--

Esto debido a la cantidad de operadores nuevos que ofrece (%--%, %m+%, %m-%, etc.).

--

Pero si trabajamos habitualmente con fechas u horas, y son un aspecto importante de nuestro trabajo, vale mucho la pena estudiarlos bien.

--

Pues `lubridate` ofrece herramientas .medium-par-red[precisas] y .medium-par-red[robustas] para el trabajo con datos temporales.

--

.medium-par[Que adem√°s son absolutamente compatibles con las librer√≠as de `tidyverse`].

--

Pueden encontrar much√≠sima m√°s informaci√≥n [aqu√≠](https://lubridate.tidyverse.org/).

---

# Uso pr√°ctico

Para crear series de tiempo

--


```r
# Identificar fecha inicio y fin
inicio &lt;- "2016-11-01"
fin &lt;- "2017-06-01"   
```

--


```r
# Contar meses entre medio
meses &lt;- ((ymd(inicio) %--% ymd(fin)) / months(1) )
meses
```

```
## [1] 7
```

--


```r
## Crear serie
ano_mes_dia &lt;- ymd(inicio) %m+% months(0:meses) %&gt;% as.character()
ano_mes_dia
```

```
## [1] "2016-11-01" "2016-12-01" "2017-01-01" "2017-02-01" "2017-03-01"
## [6] "2017-04-01" "2017-05-01" "2017-06-01"
```
--


```r
substr(ano_mes_dia,1,7) ## Si el dia molesta
```



---

# Uso pr√°ctico

Recomendaci√≥n: si haces gr√°fico con fechas aprovecha y utiliza *lubridate*

--

Cuando visualizamos variables en **a√±os** no hay mayor problema, pueden ser n√∫meros.
El tema empieza cuando hay meses o d√≠as. 

--

Veamos series de empleo (ENE): tasa de desocupaci√≥n

--


```r
# link
url &lt;- "https://www.ine.cl/docs/default-source/ocupacion-y-desocupacion/cuadros-estadisticos/series-de-tiempo-nueva-calibraci%C3%B3n-proyecciones-de-poblaci%C3%B3n-censo-2017/indicadores_principales.xlsx?sfvrsn=afbd6d15_58"

# donde guardar
destfile &lt;- "data/ine_desocupacion.xlsx"

# descargar
download.file(url, destfile, method = "curl")
```


---

# Uso pr√°ctico


```r
# cargar la data
desocup &lt;- readxl::read_excel("data/ine_desocupacion.xlsx",skip = 6,sheet = 2)
head(desocup,4)
```

```
## # A tibble: 4 x 28
##   ...1  ...2      nota...3 `en miles...4` nota...5 `en miles...6` nota...7
##   &lt;chr&gt; &lt;chr&gt;     &lt;lgl&gt;             &lt;dbl&gt; &lt;lgl&gt;             &lt;dbl&gt; &lt;lgl&gt;   
## 1 2010  Ene - Mar NA               13218. NA                7884. NA      
## 2 2010  Feb - Abr NA               13236. NA                7897. NA      
## 3 2010  Mar - May NA               13253. NA                7900. NA      
## 4 2010  Abr - Jun NA               13270. NA                7906. NA      
## # ... with 21 more variables: en miles...8 &lt;dbl&gt;, nota...9 &lt;lgl&gt;,
## #   en miles...10 &lt;dbl&gt;, nota...11 &lt;lgl&gt;, en miles...12 &lt;dbl&gt;, nota...13 &lt;chr&gt;,
## #   en miles...14 &lt;dbl&gt;, nota...15 &lt;lgl&gt;, en miles...16 &lt;dbl&gt;, nota...17 &lt;chr&gt;,
## #   en miles...18 &lt;dbl&gt;, nota...19 &lt;lgl&gt;, en miles...20 &lt;dbl&gt;, nota...21 &lt;lgl&gt;,
## #   en miles...22 &lt;dbl&gt;, nota...23 &lt;lgl&gt;, tasa (%)...24 &lt;dbl&gt;, nota...25 &lt;lgl&gt;,
## #   tasa (%)...26 &lt;dbl&gt;, nota...27 &lt;lgl&gt;, tasa (%)...28 &lt;dbl&gt;
```

--

.center[.inverse[¬øQue se ve?]]

--

Fechas como car√°cter y a√±o separado de meses. Adem√°s, meses como trimestres. 

---

# Uso pr√°ctico


```r
# Limpiar y renombrar
desocup &lt;- desocup %&gt;% janitor::clean_names() %&gt;% 
  select(x1,x2,tasa_percent_24) %&gt;% 
  filter(!is.na(x2)) %&gt;% 
  rename(ano=x1,mes=x2)
head(desocup,2)
```

```
## # A tibble: 2 x 3
##   ano   mes       tasa_percent_24
##   &lt;chr&gt; &lt;chr&gt;               &lt;dbl&gt;
## 1 2010  Ene - Mar            9.23
## 2 2010  Feb - Abr            8.84
```

--

A√±o ok, pero mes en espa√±ol y trimestre. 

--


```r
desocup$mes &lt;- tolower(substr(desocup$mes,1,3))
table(desocup$mes)
```

```
## 
## abr ago dic ene feb jul jun mar may nov oct sep 
##  12  12  11  12  12  12  12  12  12  11  11  12
```


---

# Uso pr√°ctico


```r
desocup &lt;- desocup %&gt;% 
 mutate(mes=case_when(mes == "ene" ~ 2,
                      mes == "feb" ~ 3,
                      mes == "mar" ~ 4,
                      mes == "abr" ~ 5,
                      mes == "may" ~ 6,
                      mes == "jun" ~ 7,
                      mes == "jul" ~ 8,
                      mes == "ago" ~ 9,
                      mes == "sep" ~ 10,
                      mes == "oct" ~ 11,
                      mes == "nov" ~ 12,
                      mes == "dic" ~ 1)) %&gt;% 
  mutate(fecha=make_date(year=ano,
                         month=mes))
```

--


```
## # A tibble: 3 x 4
##   ano     mes tasa_percent_24 fecha     
##   &lt;chr&gt; &lt;dbl&gt;           &lt;dbl&gt; &lt;date&gt;    
## 1 2010      2            9.23 2010-02-01
## 2 2010      3            8.84 2010-03-01
## 3 2010      4            9.09 2010-04-01
```


---

## Uso pr√°ctico

&lt;img src="2.-tiempo_files/figure-html/unnamed-chunk-47-1.png" style="display: block; margin: auto;" /&gt;

---

# El c√≥digo


```r
library(scales)
library(ggplot2)
desocup %&gt;% 
  ggplot(aes(x=fecha,y=tasa_percent_24))+
  geom_line()+
  theme_bw()+
  scale_x_date(labels = date_format("%Y-%b"),breaks='2 year' ) +
  scale_y_continuous(limits = c(0,15))
```





---

### Recursos utilizados

[Ilustraciones de Allison Horst](https://github.com/allisonhorst/stats-illustrations)

[Tutorial de `lubridate`](https://lubridate.tidyverse.org/)

[Capacitaci√≥n INE variables de tiempo en R](https://capacitacion-r-basico.github.io/sesion_4/#106)


    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
